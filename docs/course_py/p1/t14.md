Функция в python - объект, принимающий аргументы и возвращающий значение. Обычно функция определяется с помощью инструкции def.

Определим простейшую функцию:
```
def add(x, y):
	return x + y
```
Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.

Теперь мы ее можем вызвать:
```
print(add(1, 10))
#ответ 11
```
Функция может быть любой сложности и возвращать любые объекты. Функция может и не заканчиваться инструкцией return, при этом функция вернет значение None:
```
def func():
	pass

print(func())
#ответ None
```

Аргументы функции
Функция может принимать произвольное количество аргументов или не принимать их вовсе. Также распространены функции с произвольным числом аргументов, функции с позиционными и именованными аргументами, обязательными и необязательными.

```
def func(a, b, c=2): # c - необязательный аргумент
	return a + b + c
	
func(1, 2)  # a = 1, b = 2, c = 2 (по умолчанию)
#ответ 5
func(1, 2, 3)  # a = 1, b = 2, c = 3
#ответ 6
func(a=1, b=3)  # a = 1, b = 3, c = 2
#ответ 6
func(a=3, c=6)  # a = 3, c = 6, b не определен
#ответ 
#Traceback (most recent call last):
# File "", line 1, in
#    func(a=3, c=6)
#TypeError: func() takes at least 2 arguments #(2 given)
```

### Область видимости переменных
Область видимости переменных в языке программирования Python представляет собой некое пространство имен, в рамках которого функционируют созданные объекты. Эта особенность позволяет ограничивать доступ к определенным значениям во избежание конфликтов между одинаковыми идентификаторами. Переменные бывают двух видов: локальные и глобальные, что в большинстве случае определяется местом их первичной идентификации в программе.

#### Локальные переменные
Для создания переменных, обладающих локальной областью видимости, необходимо всего лишь поместить их в отдельный блок кода, изолированный от остальной программы. Чтобы увидеть локальную переменную в действии, достаточно инициализировать целочисленный объект с именем x и значением 100 в функции f, как это сделано в следующем примере:
```
def f():
    x = 100
    print(x)
f()
#ответ: 100
```
Здесь x имеет локальную область видимости, так как доступна лишь в рамках своей функции f. Вызывая данную функцию из внешней части программы, можно увидеть вывод целочисленного значения на экране. Однако, если попытаться вывести переменную x при помощи метода print вне зоны действия функции f, компилятор тут же выдаст ошибку:
```
def f():
    x = 100
    print(x)
f()
print(x)

#100
#Traceback (most recent call last):
#  File "main.py", line 5, in <module>
#    print(x)
#NameError: name 'x' is not defined
```
Так происходит из-за того, что внешняя часть программы ничего не знает о переменной x, поскольку содержит в себе совсем другое пространство имен. Пользоваться локальными объектами можно только в той области, где они были идентифицированы. В обратном же случае компилятор сообщит об ошибке, не сумев обнаружить необходимую переменную.

#### Глобальные переменные
Чтобы иметь возможность использовать некоторое значение в любой части программы, следует объявить глобальную переменную. Для этого понадобиться создать переменную отдельно от области кода, ограниченной определенным блоком кода, например, функцией. В следующем примере демонстрируется идентификация целочисленного типа данных под названием x, который позже выводится на экран при помощи метода print в функции f:
```
x = 100
def f():
    print(x)
f()
print(x)

#100
#100
```
Как можно заметить из результатов выполнения программы, значение 100 воспроизводится не только через f, но и с помощью обычного print. Таким образом, получение доступа к x осуществляется из любой части кода, благодаря глобальной области видимости подобного объекта. Но что будет, если попытаться изменить значение глобальной переменной в некой функции? Результаты такого эксперимента представлены в следующем фрагменте кода:
```
x = 100
def f():
    x = 200
f()
print(x)

#100
```
Функция f присваивает значение 200 переменной с именем x, однако, вопреки ожиданиям, внешний метод print выводит число 100, которое принадлежало x изначально. Происходит так потому, что в данной программе создаются два разных объекта x с локальной, а также глобальной областью видимости. Исправить ситуацию поможет ключевое слово global:
```
x = 100
def f():
    global x
    x = 200
f()
print(x)

#200
```
Пометив переменную x как global, можно обращаться к ее изначальному значению, которое было определено вне зоны действия функции f. Теперь после того как в x поместили число 200, вызов метода print выводит вполне ожидаемый результат, то есть измененное значение.

Настало время [практики](../../../tasks/p1/t14).